/*
 * Tendermint RPC
 *
 * Tendermint supports the following RPC protocols:  * URI over HTTP * JSONRPC over HTTP * JSONRPC over websockets  ## Configuration  RPC can be configured by tuning parameters under `[rpc]` table in the `$TMHOME/config/config.toml` file or by using the `--rpc.X` command-line flags.  Default rpc listen address is `tcp://0.0.0.0:26657`. To set another address, set the `laddr` config parameter to desired value. CORS (Cross-Origin Resource Sharing) can be enabled by setting `cors_allowed_origins`, `cors_allowed_methods`, `cors_allowed_headers` config parameters.  ## Arguments  Arguments which expect strings or byte arrays may be passed as quoted strings, like `\"abc\"` or as `0x`-prefixed strings, like `0x616263`.  ## URI/HTTP  A REST like interface.      curl localhost:26657/block?height=5  ## JSONRPC/HTTP  JSONRPC requests can be POST'd to the root RPC endpoint via HTTP.      curl --header \"Content-Type: application/json\" --request POST --data '{\"method\": \"block\", \"params\": [\"5\"], \"id\": 1}' localhost:26657  ## JSONRPC/websockets  JSONRPC requests can be also made via websocket. The websocket endpoint is at `/websocket`, e.g. `localhost:26657/websocket`. Asynchronous RPC functions like event `subscribe` and `unsubscribe` are only available via websockets.  Example using https://github.com/hashrocket/ws:      ws ws://localhost:26657/websocket     > { \"jsonrpc\": \"2.0\", \"method\": \"subscribe\", \"params\": [\"tm.event='NewBlock'\"], \"id\": 1 } 
 *
 * API version: Master
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// WebsocketApiService WebsocketApi service
type WebsocketApiService service

/*
Subscribe Subscribe for events via WebSocket.
To tell which events you want, you need to provide a query. query is a string, which has a form: \&quot;condition AND condition ...\&quot; (no OR at the moment). condition has a form: \&quot;key operation operand\&quot;. key is a string with a restricted set of possible symbols ( \\t\\n\\r\\\\()\&quot;&#39;&#x3D;&gt;&lt; are not allowed). operation can be \&quot;&#x3D;\&quot;, \&quot;&lt;\&quot;, \&quot;&lt;&#x3D;\&quot;, \&quot;&gt;\&quot;, \&quot;&gt;&#x3D;\&quot;, \&quot;CONTAINS\&quot; AND \&quot;EXISTS\&quot;. operand can be a string (escaped with single quotes), number, date or time.  Examples:       tm.event &#x3D; &#39;NewBlock&#39;               # new blocks       tm.event &#x3D; &#39;CompleteProposal&#39;       # node got a complete proposal       tm.event &#x3D; &#39;Tx&#39; AND tx.hash &#x3D; &#39;XYZ&#39; # single transaction       tm.event &#x3D; &#39;Tx&#39; AND tx.height &#x3D; 5   # all txs of the fifth block       tx.height &#x3D; 5                       # all txs of the fifth block  Tendermint provides a few predefined keys: tm.event, tx.hash and tx.height. Note for transactions, you can define additional keys by providing events with DeliverTx response.  import (     abci \&quot;github.com/tendermint/tendermint/abci/types\&quot;     \&quot;github.com/tendermint/tendermint/libs/pubsub/query\&quot; )  abci.ResponseDeliverTx{   Events: []abci.Event{       {           Type: \&quot;rewards.withdraw\&quot;,           Attributes: kv.Pairs{               kv.Pair{Key: []byte(\&quot;address\&quot;), Value: []byte(\&quot;AddrA\&quot;)},               kv.Pair{Key: []byte(\&quot;source\&quot;), Value: []byte(\&quot;SrcX\&quot;)},               kv.Pair{Key: []byte(\&quot;amount\&quot;), Value: []byte(\&quot;...\&quot;)},               kv.Pair{Key: []byte(\&quot;balance\&quot;), Value: []byte(\&quot;...\&quot;)},           },       },       {           Type: \&quot;rewards.withdraw\&quot;,           Attributes: kv.Pairs{               kv.Pair{Key: []byte(\&quot;address\&quot;), Value: []byte(\&quot;AddrB\&quot;)},               kv.Pair{Key: []byte(\&quot;source\&quot;), Value: []byte(\&quot;SrcY\&quot;)},               kv.Pair{Key: []byte(\&quot;amount\&quot;), Value: []byte(\&quot;...\&quot;)},               kv.Pair{Key: []byte(\&quot;balance\&quot;), Value: []byte(\&quot;...\&quot;)},           },       },       {           Type: \&quot;transfer\&quot;,           Attributes: kv.Pairs{               kv.Pair{Key: []byte(\&quot;sender\&quot;), Value: []byte(\&quot;AddrC\&quot;)},               kv.Pair{Key: []byte(\&quot;recipient\&quot;), Value: []byte(\&quot;AddrD\&quot;)},               kv.Pair{Key: []byte(\&quot;amount\&quot;), Value: []byte(\&quot;...\&quot;)},           },       },   }, }  All events are indexed by a composite key of the form {eventType}.{evenAttrKey}. In the above examples, the following keys would be indexed:    - rewards.withdraw.address    - rewards.withdraw.source    - rewards.withdraw.amount    - rewards.withdraw.balance    - transfer.sender    - transfer.recipient    - transfer.amount  Multiple event types with duplicate keys are allowed and are meant to categorize unique and distinct events. In the above example, all events indexed under the key &#x60;rewards.withdraw.address&#x60; will have the following values stored and queryable:     - AddrA    - AddrB  To create a query for txs where address AddrA withdrew rewards: query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND rewards.withdraw.address &#x3D; &#39;AddrA&#39;\&quot;)  To create a query for txs where address AddrA withdrew rewards from source Y: query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND rewards.withdraw.address &#x3D; &#39;AddrA&#39; AND rewards.withdraw.source &#x3D; &#39;Y&#39;\&quot;)  To create a query for txs where AddrA transferred funds: query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND transfer.sender &#x3D; &#39;AddrA&#39;\&quot;)  The following queries would return no results: query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND transfer.sender &#x3D; &#39;AddrZ&#39;\&quot;) query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND rewards.withdraw.address &#x3D; &#39;AddrZ&#39;\&quot;) query.MustParse(\&quot;tm.event &#x3D; &#39;Tx&#39; AND rewards.withdraw.source &#x3D; &#39;W&#39;\&quot;)  See list of all possible events here https://godoc.org/github.com/tendermint/tendermint/types#pkg-constants  For complete query syntax, check out https://godoc.org/github.com/tendermint/tendermint/libs/pubsub/query.  &#x60;&#x60;&#x60;go import rpchttp \&quot;github.com/tendermint/rpc/client/http\&quot; import \&quot;github.com/tendermint/tendermint/types\&quot;  client :&#x3D; rpchttp.New(\&quot;tcp:0.0.0.0:26657\&quot;, \&quot;/websocket\&quot;) err :&#x3D; client.Start() if err !&#x3D; nil {   handle error } defer client.Stop() ctx, cancel :&#x3D; context.WithTimeout(context.Background(), 1 * time.Second) defer cancel() query :&#x3D; \&quot;tm.event &#x3D; &#39;Tx&#39; AND tx.height &#x3D; 3\&quot; txs, err :&#x3D; client.Subscribe(ctx, \&quot;test-client\&quot;, query) if err !&#x3D; nil {   handle error }  go func() {  for e :&#x3D; range txs {    fmt.Println(\&quot;got \&quot;, e.Data.(types.EventDataTx))    } }() &#x60;&#x60;&#x60;  NOTE: if you&#39;re not reading events fast enough, Tendermint might terminate the subscription. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param query query is a string, which has a form: \"condition AND condition ...\" (no OR at the moment). condition has a form: \"key operation operand\". key is a string with a restricted set of possible symbols ( \\t\\n\\r\\\\()\"'=>< are not allowed). operation can be \"=\", \"<\", \"<=\", \">\", \">=\", \"CONTAINS\". operand can be a string (escaped with single quotes), number, date or time. 
@return EmptyResponse
*/
func (a *WebsocketApiService) Subscribe(ctx _context.Context, query string) (EmptyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EmptyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/subscribe"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("query", parameterToString(query, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
Unsubscribe Unsubscribe from event on Websocket
&#x60;&#x60;&#x60;go client :&#x3D; rpchttp.New(\&quot;tcp:0.0.0.0:26657\&quot;, \&quot;/websocket\&quot;) err :&#x3D; client.Start() if err !&#x3D; nil {    handle error } defer client.Stop() query :&#x3D; \&quot;tm.event &#x3D; &#39;Tx&#39; AND tx.height &#x3D; 3\&quot; err &#x3D; client.Unsubscribe(context.Background(), \&quot;test-client\&quot;, query) if err !&#x3D; nil {    handle error } &#x60;&#x60;&#x60; 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param query query is a string, which has a form: \"condition AND condition ...\" (no OR at the moment). condition has a form: \"key operation operand\". key is a string with a restricted set of possible symbols ( \\t\\n\\r\\\\()\"'=>< are not allowed). operation can be \"=\", \"<\", \"<=\", \">\", \">=\", \"CONTAINS\". operand can be a string (escaped with single quotes), number, date or time. 
@return EmptyResponse
*/
func (a *WebsocketApiService) Unsubscribe(ctx _context.Context, query string) (EmptyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EmptyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/unsubscribe"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("query", parameterToString(query, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
UnsubscribeAll Unsubscribe from all events via WebSocket
Unsubscribe from all events via WebSocket 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return EmptyResponse
*/
func (a *WebsocketApiService) UnsubscribeAll(ctx _context.Context) (EmptyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EmptyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/unsubscribe_all"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
